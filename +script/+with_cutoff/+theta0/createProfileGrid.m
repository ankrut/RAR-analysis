function createProfileGrid
searchCfg	= lib.require(@configs.solutionSearchConfig);

% set seed model struct
opts		= struct('xmax', 1E20, 'tau', 1E-16, 'rtau', 1E-4);
param.seed	= struct('beta0', 1E-6, 'W0', 36);
vm.seed		= struct('param', param.seed, 'options', opts);

% nlinfit options cascade
nlOpts				= statset('nlinfit');
nlOpts.FunValCheck	= 'off';
nlOpts.MaxIter		= 50;
nlOpts.TolX			= 1E-12;
nlOpts.DerivStep	= 1E-9;

% set golden section search options
goOpts				= struct('tau',1E-12,'rtau',1E-8,'MaxIter',50);

% find cored-cuspy transition point
% (minimum surface radius for cored regime)
[p.trans,vm.trans] = script.gosect.theta0(...
	'model',	vm.seed,...
	'list',		lib.module.ProfileResponse(searchCfg.ResponseList.rsorc,'min'),...
	'interval',	[18,19],...
	'gosect',	{'options',goOpts} ...
);

% find cuspy-deficit transition point
[p.trans2,vm.trans2] = script.gosect.theta0(...
	'model',	vm.seed,...
	'list',		lib.module.ProfileResponse(searchCfg.ResponseList.rsorp,'min'),...
	'interval',	[19.5,20.5],...
	'gosect',	{'options',goOpts} ...
);

% find deficit-disrupt transition point
[p.trans3,vm.trans3] = script.gosect.theta0(...
	'model',	vm.seed,...
	'list',		lib.module.ProfileResponse(@(SOL) 1/searchCfg.ResponseList.rsorc(SOL),'min'),...
	'interval',	[20,20.5],...
	'gosect',	{'options',goOpts} ...
);

% set diluted limit
vm.diluted	= lib.struct.setfield(vm.seed,'param/theta0',-10);
p.diluted	= lib.model.tov.rar.profile('model',vm.diluted);


% cored
rsorcMin	= searchCfg.ResponseList.rsorc(p.trans);
rsorcMax	= searchCfg.ResponseList.rsorc(p.diluted);
TBL.cored = script.createGrid(...
	'key',			'rsorc',...
	'grid',			logspace(log10(rsorcMax),log10(rsorcMin),51),...
	'model',		lib.struct.setfield(vm.seed,'param/theta0',0),...
	'searchCfg',	searchCfg,...
	'fSearch',		@script.with_cutoff.theta0.findSolution,...
	'fEstimate',	@script.with_cutoff.theta0.estimateModelStruct ...
);


% cuspy
rsorcMin	= searchCfg.ResponseList.rsorc(p.trans);
rsorcMax	= searchCfg.ResponseList.rsorc(p.trans2);

grid = logspace(log10(rsorcMin),log10(rsorcMax),51);

T1 = script.createGrid(...
	'key',			'rsorc',...
	'grid',			grid(1:10),...
	'model',		vm.trans,...
	'searchCfg',	searchCfg,...
	'fSearch',		@script.with_cutoff.theta0.findSolutionCuspy ...
);

T2 = script.createGrid(...
	'key',			'rsorc',...
	'grid',			grid(end:-1:11),...
	'model',		vm.trans2,...
	'searchCfg',	searchCfg,...
	'fSearch',		@script.with_cutoff.theta0.findSolutionCuspy2 ...
);

TBL.cuspy = lib.module.array().append(T1).append(T2);

% deficit
rsorcMin	= searchCfg.ResponseList.rsorc(p.trans2);
rsorcMax	= searchCfg.ResponseList.rsorc(p.trans3);

TBL.deficit = script.createGrid(...
	'key',			'rsorc',...
	'grid',			logspace(log10(rsorcMin),log10(rsorcMax),21),...
	'model',		vm.trans2,...
	'searchCfg',	searchCfg,...
	'fSearch',		@script.with_cutoff.theta0.findSolution,...
	'search',		{'nlinfit', {'options', nlOpts}} ...
);

% disrupted
vm.disrupt		= lib.struct.setfield(vm.seed,'param/theta0',40);
p.disrupt		= lib.model.tov.rar.profile('model',vm.disrupt);

rsorcMin	= searchCfg.ResponseList.rsorc(p.disrupt);
rsorcMax	= searchCfg.ResponseList.rsorc(p.trans3);
TBL.disrupt = script.createGrid(...
	'key',			'rsorc',...
	'grid',			logspace(log10(rsorcMin),log10(rsorcMax),21),...
	'model',		vm.disrupt,...
	'searchCfg',	searchCfg,...
	'fSearch',		@script.with_cutoff.theta0.findSolution,...
	'search',		{'nlinfit', {'options', nlOpts}} ...
);

lib.save('export/TblProfileTheta0.mat',TBL)

