function varargout = bisect(vm,response,varargin)
% relative distance function
fResponse = @(SOL) 1 - response.map(SOL)/response.prediction;

% set iteration print function
sPrec	= '%1.15e';
sFormat = strjoin({sPrec,sPrec,sPrec,'%1.3e\n'},'\t');
fLog	= @(SOL) fprintf(sFormat,SOL.data.beta0,SOL.data.theta0,SOL.data.W0,response.chi2(SOL));

% set model function (solution => struct)
fModel = @(SOL) struct(...
	'param', struct(...
		'beta0',	SOL.data.beta0,...
		'theta0',	SOL.data.theta0,...
		'W0',		SOL.data.W0 ...
	),...
	'options',	vm.options ...
);

% set solution function (struct => solution)
fSolution = @(vm) model.tov.rar.quick(vm);

% set default bisect options
opts = struct(...
	'tau',		1E-6,...
	'MaxIter',	40 ...
);

% search for solution
[varargout{1:nargout}] = lib.fitting.bisect(...
	'model',		vm,...
	'fResponse',	fResponse,...
	'fModel',		fModel,...
	'fSolution',	fSolution,...
	'fLog',			fLog,...
	'onNaN',		@onNaN,...
	'options',		opts,...
	varargin{:} ...
);


function [Xint,dY] = onNaN(Xint,dY)
if isnan(dY(1)) && isnan(dY(3))
	error('badly chosen interval. Interval edges give NaN.')
elseif isnan(dY(1))
	if sign(dY(2)) == sign(dY(3)) && abs(dY(2)) < abs(dY(3))
		Xint = [Xint(1), mean(Xint)];
		dY(3) = dY(2);
	else
		Xint = [mean(Xint), Xint(2)];
		dY(1) = dY(2);
	end
elseif isnan(dY(3))
	if sign(dY(2)) == sign(dY(1)) && abs(dY(2)) < abs(dY(1))
		Xint = [mean(Xint),Xint(2)];
		dY(1) = dY(2);
	else
		Xint = [Xint(1), mean(Xint)];
		dY(3) = dY(2);
	end
end